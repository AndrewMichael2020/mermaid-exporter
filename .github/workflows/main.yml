name: CI & Deploy (Consolidated)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: {}

jobs:
  ci:
    name: CI — lint, typecheck, test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint (via npm script)
        run: npm run lint -- --max-warnings 0
        continue-on-error: true

      - name: Run TypeScript type check
        run: npm run typecheck
        continue-on-error: true

      - name: Run tests with coverage
        run: npm run test -- --ci --coverage

      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage/
          retention-days: 7

  deploy:
    name: Deploy to Cloud Run
    needs: ci
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref == 'refs/heads/main') }}
    runs-on: ubuntu-latest
    env:
      # Prefer repository secrets for project/service/region so the workflow matches your repo
      PROJECT: ${{ secrets.GCP_PROJECT }}
      SERVICE: ${{ secrets.CLOUD_RUN_SERVICE }}
      DEFAULT_REGION: ${{ secrets.CLOUD_RUN_REGION }}
      # Provide repo secrets as environment variables (they will be empty if not set)
      NEXT_PUBLIC_FIREBASE_API_KEY: ${{ secrets.NEXT_PUBLIC_FIREBASE_API_KEY }}
      NEXT_PUBLIC_FIREBASE_PROJECT_ID: ${{ secrets.NEXT_PUBLIC_FIREBASE_PROJECT_ID }}
      NEXT_PUBLIC_FIREBASE_APP_ID: ${{ secrets.NEXT_PUBLIC_FIREBASE_APP_ID }}
      NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN: ${{ secrets.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN }}
      NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET: ${{ secrets.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET }}
      NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID: ${{ secrets.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID }}
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      # Marker list used to iterate when checking both env and Secret Manager
      SECRETS_TO_CHECK: |
        NEXT_PUBLIC_FIREBASE_API_KEY
        NEXT_PUBLIC_FIREBASE_PROJECT_ID
        NEXT_PUBLIC_FIREBASE_APP_ID
        NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN
        NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET
        NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID
        GEMINI_API_KEY
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Verify gcloud authentication (debug)
        run: |
          set -euo pipefail
          echo "gcloud version:"
          gcloud --version
          echo "Active account:" 
          gcloud auth list --format='value(account)' || true
          if [ -z "$(gcloud auth list --format='value(account)')" ]; then
            echo "::error::gcloud has no active account. Check GCP_SA_KEY secret." 
            exit 1
          fi

      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure gcloud defaults
        run: |
          set -euo pipefail
          gcloud config set project "$PROJECT"
          gcloud config set run/region "$DEFAULT_REGION"

      - name: Verify required secrets exist (Secret Manager or repo secrets)
        run: |
          set -euo pipefail
          IFS=$'\n' read -r -d '' -a secrets <<< "${{ env.SECRETS_TO_CHECK }}" 2>/dev/null || true
          missing_secrets=()
          for s in "${secrets[@]}"; do
            s=$(echo "$s" | xargs)
            if [ -z "$s" ]; then
              continue
            fi
            # First check if a repository secret was provided and mapped into the environment
            env_val=""
            case "$s" in
              NEXT_PUBLIC_FIREBASE_API_KEY)
                env_val="${NEXT_PUBLIC_FIREBASE_API_KEY:-}"
                ;;
              NEXT_PUBLIC_FIREBASE_PROJECT_ID)
                env_val="${NEXT_PUBLIC_FIREBASE_PROJECT_ID:-}"
                ;;
              NEXT_PUBLIC_FIREBASE_APP_ID)
                env_val="${NEXT_PUBLIC_FIREBASE_APP_ID:-}"
                ;;
              NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN)
                env_val="${NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN:-}"
                ;;
              NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET)
                env_val="${NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET:-}"
                ;;
              NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID)
                env_val="${NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID:-}"
                ;;
              GEMINI_API_KEY)
                env_val="${GEMINI_API_KEY:-}"
                ;;
              *)
                env_val=""
                ;;
            esac

            if [ -n "$env_val" ]; then
              echo "Using repository secret for $s (present in runner environment)."
              continue
            fi

            echo "Checking Secret Manager for $s..."
            if ! gcloud secrets describe "$s" --project "$PROJECT" >/dev/null 2>&1; then
              missing_secrets+=("$s")
            fi
          done
          if [ ${#missing_secrets[@]} -gt 0 ]; then
            echo "::warning::Missing secrets in Secret Manager and not provided as repo secrets: ${missing_secrets[*]}"
            echo "Deployment will continue, but runtime behavior may fail if the app expects these values."
            echo "To provision them in Cloud: gcloud secrets create <NAME> --replication-policy=automatic --project=$PROJECT && echo -n '<value>' | gcloud secrets versions add <NAME> --data-file=- --project=$PROJECT"
          else
            echo "All required secrets verified (either repo secrets or Secret Manager)."
          fi

      - name: Build and push image (Cloud Build)
        id: build_image
        env:
          GITHUB_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          TAG="${GITHUB_SHA:0:7}"
          IMAGE_TAG="gcr.io/${PROJECT}/${SERVICE}:${TAG}"
          IMAGE_LATEST="gcr.io/${PROJECT}/${SERVICE}:latest"
          echo "Building $IMAGE_TAG"
          # Submit build (Cloud Build will push tags)
          BUILD_ID=$(gcloud builds submit --tag "$IMAGE_TAG" --tag "$IMAGE_LATEST" --format='get(id)' --timeout=1200s)
          echo "Build ID: $BUILD_ID"

          # Try to read the image digest from Container Registry listing. This avoids describing the build record (which can 404 transiently).
          DIGEST=""
          for i in $(seq 1 12); do
            echo "Attempt $i: checking container image list for tag ${TAG} or latest..."
            # First try the specific tag
            DIGEST=$(gcloud container images list-tags "gcr.io/${PROJECT}/${SERVICE}" --filter="tags:${TAG}" --format='get(digest)' --limit=1 2>/dev/null || true)
            if [ -n "$DIGEST" ]; then
              echo "Found digest for tag ${TAG}: $DIGEST"
              break
            fi
            # Fallback to latest if specific tag not found yet
            DIGEST=$(gcloud container images list-tags "gcr.io/${PROJECT}/${SERVICE}" --filter="tags:latest" --format='get(digest)' --limit=1 2>/dev/null || true)
            if [ -n "$DIGEST" ]; then
              echo "Found digest for tag latest: $DIGEST"
              break
            fi
            echo "Image not available yet (attempt $i). Sleeping 10s..."
            sleep 10
          done
          if [ -z "$DIGEST" ]; then
            echo "::error::Failed to retrieve image digest for pushed image (project=${PROJECT}, service=${SERVICE}, build=${BUILD_ID})"
            # Dump some debug info
            echo "Listing images (short):"
            gcloud container images list --repository="gcr.io/${PROJECT}" || true
            exit 1
          fi
          IMAGE_DIGEST="gcr.io/${PROJECT}/${SERVICE}@${DIGEST}"
          echo "IMAGE_DIGEST=$IMAGE_DIGEST" >> "$GITHUB_OUTPUT"

      - name: Deploy to Cloud Run
        run: |
          set -euo pipefail
          # Use the digest produced by the Cloud Build step to avoid tag race conditions
          IMAGE="${{ steps.build_image.outputs.IMAGE_DIGEST }}"
          echo "Deploying $SERVICE to Cloud Run ($DEFAULT_REGION) using image: $IMAGE"
          update_secrets_args=()
          IFS=$'\n' read -r -d '' -a secrets <<< "${{ env.SECRETS_TO_CHECK }}" 2>/dev/null || true
          for s in "${secrets[@]}"; do
            s=$(echo "$s" | xargs)
            if [ -z "$s" ]; then
              continue
            fi
            update_secrets_args+=("--update-secrets" "$s=$s:latest")
          done
          gcloud run deploy "$SERVICE" \
            --image "$IMAGE" \
            --region "$DEFAULT_REGION" \
            --platform managed \
            --allow-unauthenticated \
            --port 8080 \
            --memory 512Mi \
            --cpu 1 \
            --min-instances 0 \
            --max-instances 10 \
            "${update_secrets_args[@]}"

      - name: Get Cloud Run Service URL
        id: service_url
        run: |
          set -euo pipefail
          url=$(gcloud run services describe "$SERVICE" --platform managed --region "$DEFAULT_REGION" --format='value(status.url)')
          echo "Cloud Run Service URL: $url"
          echo "service_url=$url" >> "$GITHUB_OUTPUT"

      - name: Health check
        env:
          SERVICE_URL: ${{ steps.service_url.outputs.service_url }}
        run: |
          set -euo pipefail
          echo "Performing health check on $SERVICE_URL..."
          max_attempts=5
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt of $max_attempts..."
            status_code=$(curl -s -o /dev/null -w "%{http_code}" "$SERVICE_URL" --max-time 30 || echo "000")
            if [ "$status_code" = "200" ]; then
              echo "✅ Health check passed! Service is healthy."
              exit 0
            fi
            echo "Received status code: $status_code"
            if [ $attempt -lt $max_attempts ]; then
              echo "Waiting 10 seconds before next attempt..."
              sleep 10
            fi
            attempt=$((attempt + 1))
          done
          echo "::warning::Health check did not return 200 after $max_attempts attempts (last status: $status_code)"
          echo "Service may still be starting up. Please verify manually at: $SERVICE_URL"

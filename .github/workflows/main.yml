name: CI & Deploy (Consolidated)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: {}

jobs:
  ci:
    name: CI — lint, typecheck, test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint (via npm script)
        run: npm run lint -- --max-warnings 0
        continue-on-error: true

      - name: Run TypeScript type check
        run: npm run typecheck
        continue-on-error: true

      - name: Run tests with coverage
        run: npm run test -- --ci --coverage

      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage/
          retention-days: 7

  deploy:
    name: Deploy to Cloud Run
    needs: ci
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref == 'refs/heads/main') }}
    runs-on: ubuntu-latest
    env:
      PROJECT: studio-1697788595-a34f5
      SERVICE: mermaid-exporter
      DEFAULT_REGION: us-central1
      SECRETS_TO_CHECK: |
        NEXT_PUBLIC_FIREBASE_API_KEY
        NEXT_PUBLIC_FIREBASE_PROJECT_ID
        NEXT_PUBLIC_FIREBASE_APP_ID
        NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN
        NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET
        NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID
        GEMINI_API_KEY
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure gcloud defaults
        run: |
          set -euo pipefail
          gcloud config set project "$PROJECT"
          gcloud config set run/region "$DEFAULT_REGION"

      - name: Verify required secrets exist in Secret Manager
        run: |
          set -euo pipefail
          IFS=$'\n' read -r -d '' -a secrets <<< "${{ env.SECRETS_TO_CHECK }}" 2>/dev/null || true
          missing_secrets=()
          for s in "${secrets[@]}"; do
            s=$(echo "$s" | xargs)
            if [ -z "$s" ]; then
              continue
            fi
            echo "Checking $s..."
            if ! gcloud secrets describe "$s" --project "$PROJECT" >/dev/null 2>&1; then
              missing_secrets+=("$s")
            fi
          done
          if [ ${#missing_secrets[@]} -gt 0 ]; then
            echo "::error::Missing secrets in Secret Manager: ${missing_secrets[*]}"
            echo "Please create them using: gcloud secrets create <SECRET_NAME> --project=$PROJECT"
            exit 1
          fi
          echo "All required secrets verified."

      - name: Build and push image (Cloud Build)
        id: build_image
        env:
          GITHUB_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          TAG="${GITHUB_SHA:0:7}"
          IMAGE_TAG="gcr.io/${PROJECT}/${SERVICE}:${TAG}"
          IMAGE_LATEST="gcr.io/${PROJECT}/${SERVICE}:latest"
          echo "Building $IMAGE_TAG"
          # Submit build and capture build id
          BUILD_ID=$(gcloud builds submit --tag "$IMAGE_TAG" --tag "$IMAGE_LATEST" --format='get(id)' --timeout=1200s)
          echo "Build ID: $BUILD_ID"
          # Retrieve the pushed image digest from the build results with retry to avoid eventual-consistency 404s
          DIGEST=""
          for i in $(seq 1 5); do
            DIGEST=$(gcloud builds describe "$BUILD_ID" --format='get(results.images[0].digest)' || true)
            if [ -n "$DIGEST" ]; then
              break
            fi
            echo "Describe build not ready yet (attempt $i). Sleeping 5s..."
            sleep 5
          done
          if [ -z "$DIGEST" ]; then
            echo "::error::Failed to retrieve image digest for build $BUILD_ID"
            exit 1
          fi
          echo "Built image digest: $DIGEST"
          IMAGE_DIGEST="gcr.io/${PROJECT}/${SERVICE}@${DIGEST}"
          echo "IMAGE_DIGEST=$IMAGE_DIGEST" >> "$GITHUB_OUTPUT"

      - name: Deploy to Cloud Run
        run: |
          set -euo pipefail
          # Use the digest produced by the Cloud Build step to avoid tag race conditions
          IMAGE="${{ steps.build_image.outputs.IMAGE_DIGEST }}"
          echo "Deploying $SERVICE to Cloud Run ($DEFAULT_REGION) using image: $IMAGE"
          update_secrets_args=()
          IFS=$'\n' read -r -d '' -a secrets <<< "${{ env.SECRETS_TO_CHECK }}" 2>/dev/null || true
          for s in "${secrets[@]}"; do
            s=$(echo "$s" | xargs)
            if [ -z "$s" ]; then
              continue
            fi
            update_secrets_args+=("--update-secrets" "$s=$s:latest")
          done
          gcloud run deploy "$SERVICE" \
            --image "$IMAGE" \
            --region "$DEFAULT_REGION" \
            --platform managed \
            --allow-unauthenticated \
            --port 8080 \
            --memory 512Mi \
            --cpu 1 \
            --min-instances 0 \
            --max-instances 10 \
            "${update_secrets_args[@]}"

      - name: Get Cloud Run Service URL
        id: service_url
        run: |
          set -euo pipefail
          url=$(gcloud run services describe "$SERVICE" --platform managed --region "$DEFAULT_REGION" --format='value(status.url)')
          echo "Cloud Run Service URL: $url"
          echo "service_url=$url" >> "$GITHUB_OUTPUT"

      - name: Health check
        env:
          SERVICE_URL: ${{ steps.service_url.outputs.service_url }}
        run: |
          set -euo pipefail
          echo "Performing health check on $SERVICE_URL..."
          max_attempts=5
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt of $max_attempts..."
            status_code=$(curl -s -o /dev/null -w "%{http_code}" "$SERVICE_URL" --max-time 30 || echo "000")
            if [ "$status_code" = "200" ]; then
              echo "✅ Health check passed! Service is healthy."
              exit 0
            fi
            echo "Received status code: $status_code"
            if [ $attempt -lt $max_attempts ]; then
              echo "Waiting 10 seconds before next attempt..."
              sleep 10
            fi
            attempt=$((attempt + 1))
          done
          echo "::warning::Health check did not return 200 after $max_attempts attempts (last status: $status_code)"
          echo "Service may still be starting up. Please verify manually at: $SERVICE_URL"
